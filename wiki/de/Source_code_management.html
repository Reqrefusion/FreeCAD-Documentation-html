<link href="../site.css" rel="stylesheet" type="text/css"/><div class="mw-page-container"><h1 id="firstHeading" class="firstHeading mw-first-heading"><span class="mw-page-title-main">Source code management/de</span></h1><?xml encoding="UTF-8"><div class="mw-content-ltr mw-parser-output" lang="de" dir="ltr"><div class="mw-pt-languages noprint navigation-not-searchable" lang="en" dir="ltr"><div class="mw-pt-languages-label">Other languages:</div><ul class="mw-pt-languages-list"><li><a href="../index.php?title=Special;Translate&amp;group=page-Source+code+management&amp;language=&amp;task=view.html" class="new" title="Start translation for this language" lang="" dir="ltr"></a></li>
<li><span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete" lang="de" dir="ltr">Deutsch</span></li>
<li><a href="../Source_code_management.html" class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" title="Source code management (100% translated)" lang="en" dir="ltr">English</a></li>
<li><a href="../es/Source_code_management.html" class="mw-pt-progress mw-pt-progress--low" title="Source code management (3% translated)" lang="es" dir="ltr">espa&ntilde;ol</a></li>
<li><a href="../fr/Source_code_management.html" class="mw-pt-progress mw-pt-progress--complete" title="Gestion du code source (100% translated)" lang="fr" dir="ltr">fran&ccedil;ais</a></li>
<li><a href="../it/Source_code_management.html" class="mw-pt-progress mw-pt-progress--med" title="Gestione del codice sorgente (19% translated)" lang="it" dir="ltr">italiano</a></li>
<li><a href="../pl/Source_code_management.html" class="mw-pt-progress mw-pt-progress--complete" title="Zarz&#261;dzanie kodem &#378;r&oacute;d&#322;owym (100% translated)" lang="pl" dir="ltr">polski</a></li>
<li><a href="../pt-br/Source_code_management.html" class="mw-pt-progress mw-pt-progress--low" title="Gerenciamento de c&oacute;digo fonte (1% translated)" lang="pt-BR" dir="ltr">portugu&ecirc;s do Brasil</a></li>
<li><a href="../ru/Source_code_management.html" class="mw-pt-progress mw-pt-progress--low" title="&#1059;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1077; &#1080;&#1089;&#1093;&#1086;&#1076;&#1085;&#1099;&#1084; &#1082;&#1086;&#1076;&#1086;&#1084; (1% translated)" lang="ru" dir="ltr">&#1088;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081;</a></li></ul></div>
<div style="clear:right; margin-bottom: .5em; float: right; padding: .5em 0 .8em 1.4em; background: none;"><meta property="mw:PageProp/toc"></div>
<p><span id="Introduction"></span>
</p>
<h2><span class="mw-headline" id="Einleitung">Einleitung</span></h2>
<p>Das Hauptwerkzeug zur Quellcodeverwaltung f&uuml;r das FreeCAD-Projekt ist <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Git_%28software%29">Git</a>, das in den meisten Betriebssystemen einfach &uuml;ber einen Paketmanager oder direkt von der Website von <a rel="nofollow" class="external text" href="https://git-scm.com/">Git</a> installiert werden kann. Es wird empfohlen, sich mit Git vertraut zu machen, bevor man direkt mit dem FreeCAD-Quellcode arbeitet. Auf der Seite <a rel="nofollow" class="external text" href="https://git-scm.com/doc">Git documentation</a> findet man das Referenzhandbuch sowie das <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2">Pro Git book</a> (beide engl.), um zu lernen, wie das System im Allgemeinen genutzt wird. Das vorliegende Dokument konzentriert sich auf die Verwendung von Git f&uuml;r die FreeCAD-Entwicklung. Die Zusammenstellung von FreeCAD ist unter <a href="../de/Compiling.html" title="Compiling/de">Kompilieren</a> beschrieben.
</p><p>W&auml;hrend Git in erster Linie eine Terminal-Anwendung ist, gibt es viele grafische Anwendungen, die die Arbeit mit Branches (Zweigen), das Anwenden von Patches und das Senden von Pull-Requests an einen Main-Branch (Hauptzweig) erleichtern. Beispiele daf&uuml;r sind <a rel="nofollow" class="external text" href="https://git-scm.com/docs/git-gui">git-gui</a> (hilft beim Staging und bei Commits, kann gitk starten), <a rel="nofollow" class="external text" href="https://git-scm.com/docs/gitk">gitk</a> (zeigt die Commmit-Historie an, die erste grafische Benutzeroberfl&auml;che, die entwickelt wurde),<a rel="nofollow" class="external text" href="https://wiki.gnome.org/Apps/Gitg/">gitg</a> (Gnome),<a rel="nofollow" class="external text" href="https://github.com/tibirna/qgit">qgit</a> (Qt), <a rel="nofollow" class="external text" href="https://jonas.github.io/tig/">tig</a> (Ncurses), <a rel="nofollow" class="external text" href="http://github.com/git-cola/git-cola">git-cola</a> und <a rel="nofollow" class="external text" href="https://www.gitkraken.com/">GitKraken</a> (propriet&auml;r). Eine kurze Einf&uuml;hrung in dieses Werkzeug findet man unter <a href="../de/Developing_FreeCAD_with_GitKraken.html" title="Developing FreeCAD with GitKraken/de">Entwicklung von FreeCAD mit GitKraken</a>.
</p><p>Hinweis: Wenn einem davon schwindelig wird, gibt es eine sehr gute nicht-technische Serie &uuml;ber die Verwendung von Git und Github mit dem Titel '<a rel="nofollow" class="external text" href="https://youtu.be/BCQHnlnPusY">Git und Github f&uuml;r Dichter</a>'.
</p><p><span id="Source_code_access"></span>
</p>
<h2><span class="mw-headline" id="Quellcodezugang">Quellcodezugang</span></h2>
<p>Jeder kann auf den FreeCAD-Quellcode zugreifen und eine Kopie davon bekommen, aber nur die FreeCAD-Projektmanager haben Schreibzugriff darauf. Man kann eine Kopie des Codes erhalten, ihn studieren und nach Belieben &auml;ndern, aber wenn man m&ouml;chte, dass die &Auml;nderungen in den offiziellen Quellcode aufgenommen werden, musst man einen &bdquo;Pull-Request&ldquo; gegen das Main-Repository durchf&uuml;hren, damit die &Auml;nderungen von den Verwaltern &uuml;berpr&uuml;ft werden k&ouml;nnen. Diese Art der Entwicklung ist bekannt als der <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows">Dictator and Lieutenants Workflow</a> (engl. w&ouml;rtlich etwa &bdquo;Diktator und Leutnants-Arbeitsablauf&ldquo;), da die Kern-Entwickler (Diktatoren) und betrauten Entwickler (Leutnante) den Code filtern, der von unabh&auml;ngigen Entwicklern und Benutzern eingereicht wird.
</p><p>Wenn die Quellcode-&Auml;nderungen signifikant sind, empfehlen wir, sie im Pull-Request-Abschnitt des <a rel="nofollow" class="external text" href="https://forum.freecad.org/viewforum.php?f=17">FreeCAD-Forums</a> zu erkl&auml;ren.
</p>
<p><span typeof="mw:File"><a href="../index.php?title=FreeCAD_git_workflow.svg&amp;filetimestamp=20240907205435&amp;.html" class="mw-file-description"><img src="../File/FreeCAD_git_workflow.svg" decoding="async" width="600" height="340" class="mw-file-element" data-file-width="578" data-file-height="328"></a></span> </p><p style="text-align:left; font-style:italic; max-width:800px; box-sizing:border-box; margin-block:1em; margin-inline:clamp(1em, 6vw, 2em); padding-inline:clamp(0.75em, 4vw, 2em); word-break:normal; overflow-wrap:break-word;">Typischer Arbeitsablauf zur Entwicklung von Code f&uuml;r FreeCAD; jeder kann den Code aus dem Haupt-Repository beziehen, aber die Hauptentwickler haben das exklusive Recht, Eingaben anderer Entwickler zu &uuml;berpr&uuml;fen und zusammenzuf&uuml;hren.</p>
<p><span id="Official_GitHub_repository"></span>
</p>
<h3><span class="mw-headline" id="Offizielles_GitHub-Repository">Offizielles GitHub-Repository</span></h3>
<p>Der FreeCAD-Quellcode wird in Github bereitgestellt, <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD">https://github.com/FreeCAD/FreeCAD</a></code>
</p><p>Um Code beitragen zu k&ouml;nnen, wird ein <a rel="nofollow" class="external text" href="https://github.com/join">GitHub-Konto</a> ben&ouml;tigt.
</p><p>In der Vergangenheit wurde der Quellcode in einem SVN-Repository bereitgestellt, <code><a rel="nofollow" class="external free" href="https://free-cad.svn.sourceforge.net/svnroot/free-cad">https://free-cad.svn.sourceforge.net/svnroot/free-cad</a></code>. Dieses wurde am 10. Oktober 2011 mit <a rel="nofollow" class="external text" href="https://github.com/FreeCAD/FreeCAD/commit/120ca87015">commit 120ca87015</a> nach GitHub verschoben.
</p>
<dl><dd>Daher gibt es viele &Auml;nderungen, die vor dieser Zeit vorgenommen wurden, die nicht in der modernen Git-Commit-Geschichte aufgezeichnet sind. Mehr dazu kann man auf der Seite <a href="../de/History.html" title="History/de">Geschichte</a> nachlesen.</dd></dl>
<p><span id="Setting_your_Git_username"></span>
</p>
<h3><span class="mw-headline" id="Git-Benutzernamen_festlegen">Git-Benutzernamen festlegen</span></h3>
<p>Entwickler sollten Code in ihr pers&ouml;nliches Repository mit ihrem GitHub-Benutzernamen eintragen. Wenn dieser nicht bereits global gesetzt ist, kann er lokal f&uuml;r das aktuelle Git-Repository wie folgt gesetzt werden:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git config user.name "YOUR_NAME"
git config user.email GITHUB_USERNAME@users.noreply.github.com
</pre></div>
<p>Wobei <code>&bdquo;YOUR_NAME&ldquo;</code> den vollst&auml;ndigen Namen oder Spitznamen darstellt, der zur Identifizierung des Autors eines bestimmten Beitrags verwendet wird, und <code>GITHUB_USERNAME</code> den Namen des Accounts auf GitHub angibt.
</p><p><span id="Remote_repositories"></span>
</p>
<h3><span class="mw-headline" id="Remote_Repositories">Remote Repositories</span></h3>
<p>Man lese <a rel="nofollow" class="external text" href="https://stackoverflow.com/questions/9257533/what-is-the-difference-between-origin-and-upstream-on-github#9257901">Was ist der Unterschied zwischen Origin und Upstream auf GitHub?</a> (Stackoverflow), um den Unterschied zwischen <code>origin</code> und <code>upstream</code> im Zusammenhang mit Git zu verstehen. In diesem Abschnitt wird erkl&auml;rt, wie die richtigen Repositorys f&uuml;r die Entwicklung eingerichtet werden.
Im Wesentlichen:
</p>
<ul><li><code>origin</code> ist der pers&ouml;nliche Fork des offiziellen FreeCAD-Projektarchivs, also <code><a rel="nofollow" class="external free" href="https://github.com/GITHUB_USERNAME/FreeCAD">https://github.com/GITHUB_USERNAME/FreeCAD</a></code></li>
<li><code>upstream</code> ist das offizielle FreeCAD-Repository, d. h. <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD">https://github.com/FreeCAD/FreeCAD</a></code></li></ul>
<p>Diese Unterscheidung ist wichtig, da man den Code zun&auml;chst in der eigenen Kopie des Repositorys schreiben sollte, bevor man diese &Auml;nderungen in das offizielle Repository &uuml;bertr&auml;gt.
</p><p>Basierend auf den obigen Ausf&uuml;hrungen gibt es zwei M&ouml;glichkeiten, die Git-Entwicklungsumgebung einzurichten:
</p>
<ul><li>1. Methode: Auf GitHub forken und den Fork lokal klonen.</li>
<li>2. Methode: FreeCAD direkt auf dem lokalen Rechner klonen und die Remote-Server anpassen.</li></ul>
<p>Wir empfehlen die erste Methode, weil sie einen Schritt schneller ist.
</p>
<div class="mw-collapsible mw-collapsed toccolours">
<p><span id="1st_Method:_Fork_on_GitHub_and_clone_your_fork_locally"></span>
</p>
<h4><span class="mw-headline" id="Erste_Methode:_Auf_GitHub_forken_und_den_eigenen_Fork_lokal_klonen">Erste Methode:  Auf GitHub forken und den eigenen Fork lokal klonen</span></h4>
<div class="mw-collapsible-content">
<p>Zuerst wird das FreeCAD-Repository in GitHub geforkt, dann klont man diesen pers&ouml;nlichen Fork auf dem Computer und legt schlie&szlig;lich das <code>upstream</code>-Repository fest.
</p>
<ul><li>Beim GitHub-Konto <a rel="nofollow" class="external text" href="https://github.com/join">Anmelden</a>.</li>
<li>Zum offiziellen FreeCAD-Repository gehen: <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD">https://github.com/FreeCAD/FreeCAD</a></code></li>
<li>Oben rechts auf der Seite auf die Schaltfl&auml;che &bdquo;Fork&ldquo; klicken. Dadurch wird eine pers&ouml;nliche Kopie des FreeCAD-Repositorys unter dem GitHub-Benutzernamen erstellt: <code>https://github.com/GITHUB_USERNAME/FreeCAD</code></li>
<li>Auf dem Rechner den neu erstellten FreeCAD-Fork klonen. Er wird in einem Verzeichnis <code>freecad-source</code> erstellt.</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git clone https://github.com/GITHUB_USERNAME/FreeCAD.git freecad-source
</pre></div>
<ul><li>Sobald der Download abgeschlossen ist, gibt man das neue Quellverzeichnis ein und legt das <code>upstream</code>-Repository fest.</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>cd  freecad-source
git remote add upstream https://github.com/FreeCAD/FreeCAD.git
</pre></div>
<ul><li>Best&auml;tige deine Fernrepositorien mit <code>git remote -v</code>; die Ausgabe sollte &auml;hnlich wie diese sein</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>origin	https://github.com/GITHUB_USERNAME/FreeCAD.git (fetch)
origin	https://github.com/GITHUB_USERNAME/FreeCAD.git (push)
upstream	https://github.com/FreeCAD/FreeCAD.git (fetch)
upstream	https://github.com/FreeCAD/FreeCAD.git (push)
</pre></div>
<ul><li>Jetzt kann die Entwicklung beginnen.</li></ul>
</div>
</div>
<div class="mw-collapsible mw-collapsed toccolours">
<p><span id="2nd_Method:_Clone_FreeCAD_directly_to_your_local_machine"></span>
</p>
<h4><span class="mw-headline" id="2._Methode:_FreeCAD_direkt_auf_den_eigenen_lokalen_Rechner_klonen">2. Methode: FreeCAD direkt auf den eigenen lokalen Rechner klonen</span></h4>
<div class="mw-collapsible-content">
<p>Zuerst wirst du das FreeCAD Repositorium in GitHub abspalten (engl.:fork &sbquo;Gabel&lsquo;), jedoch wirst du das urspr&uuml;ngliche FreeCAD Repositorium auf deinen lokalen Rechner klonen und dann deine Fernbedienungen &uuml;ber das Terminal &auml;ndern.
</p>
<ul><li><a rel="nofollow" class="external text" href="https://github.com/join">Anmelden</a> auf dein GitHub Konto.</li>
<li>Gehe zum offiziellen FreeCAD Repositorium: <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD">https://github.com/FreeCAD/FreeCAD</a></code></li>
<li>Klicke oben rechts auf der Seite auf die "Fork" Schaltfl&auml;che. Dadurch wird eine pers&ouml;nliche Kopie des FreeCAD Repositoriums unter deinem GitHub Benutzernamen erstellt: <code>https://github.com/GITHUB_USERNAME/FreeCAD</code></li>
<li>Klone das urspr&uuml;ngliche FreeCAD Repositorium. Es wird in einem Verzeichnis <code>freecad-source</code> erstellt.</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git clone https://github.com/FreeCAD/FreeCAD.git freecad-source
</pre></div>
<ul><li>Sobald das Herunterladen abgeschlossen ist, gib das neue Quellverzeichnis ein und lege das <code>Ursprung</code>s Repositorium fest.</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>cd freecad-source
git remote add origin https://github.com/GITHUB_USERNAME/FreeCAD.git
</pre></div>
<ul><li>Richte dann das <code>upstream</code> Repositorium ein.</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git remote add upstream https://github.com/FreeCAD/FreeCAD.git
</pre></div>
<ul><li>Best&auml;tige deine Fernrepositorien mit <code>git remote -v</code>; die Ausgabe sollte &auml;hnlich wie diese sein</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>origin	https://github.com/GITHUB_USERNAME/FreeCAD.git (fetch)
origin	https://github.com/GITHUB_USERNAME/FreeCAD.git (push)
upstream	https://github.com/FreeCAD/FreeCAD.git (fetch)
upstream	https://github.com/FreeCAD/FreeCAD.git (push)
</pre></div>
<ul><li>Jetzt kann die Entwicklung beginnen.</li></ul>
</div>
</div>
<p>Wenn die Fernrepositorien aus irgendeinem Grund zwar existieren, aber auf die falsche Adresse verweisen, kannst du die Situation durch Umbenennen des Namens des entfernten Repositoriums beheben. Beispielsweise sollte <code>Ursprung</code> auf deine pers&ouml;nliche Abspaltung zeigen; wenn er auf das urspr&uuml;ngliche FreeCAD Repositorium zeigt, &auml;ndere den Namen dieses Fernrepositoriums in <code>upstream</code> und f&uuml;ge das <code>Ursprung</code>s Repositorium manuell hinzu.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git remote rename origin upstream
git remote add origin https://github.com/GITHUB_USERNAME/FreeCAD.git
git remote -v
</pre></div>
<p>Du kannst auch weitere Informationen mit dem Schl&uuml;sselwort <code>anzeigen</code> anzeigen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git remote show origin
git remote show upstream
</pre></div>
<p><span id="Git_development_process"></span>
</p>
<h2><span class="mw-headline" id="Git-Entwicklungsprozess">Git-Entwicklungsprozess</span></h2>
<div class="warning-box">Niemals auf dem eigenen lokalen <i>Main</i>-Zweig entwickeln. Erstelle stattdessen einen lokalen Zweig f&uuml;r die Entwicklung, und f&uuml;hre diesen lokalen Zweig dann &uuml;ber eine Pull-Anforderung mit dem vorgeschalteten Main-Zweig zusammen. Lies bitte <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">Git-Verzweigung</a>, <a rel="nofollow" class="external text" href="https://book.git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">Grundlegende Verzweigung und Zusammenf&uuml;hrung</a> und <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/GitHub-Contributing-to-a-Project">GitHub - An einem Projekt mitwirken</a>, um mehr zu erfahren.</div>
<p><span typeof="mw:File"><a href="../index.php?title=FreeCAD_git_branches_workflow.svg&amp;filetimestamp=20240907205343&amp;.html" class="mw-file-description"><img src="../File/FreeCAD_git_branches_workflow.svg" decoding="async" width="800" height="426" class="mw-file-element" data-file-width="779" data-file-height="415"></a></span>
</p>
<p style="text-align:left; font-style:italic; max-width:800px; box-sizing:border-box; margin-block:1em; margin-inline:clamp(1em, 6vw, 2em); padding-inline:clamp(0.75em, 4vw, 2em); word-break:normal; overflow-wrap:break-word;">Generischer Arbeitsablauf zur Entwicklung von Code f&uuml;r FreeCAD unter Verwendung von <code>git</code>; das Haupt Repositorium wird online gespalten und auf einen Offline Rechner geklont (0); neue Zweige (1) werden verwendet, um lokale &Auml;nderungen und Erg&auml;nzungen des Codes zu &uuml;bergeben (2); die Zweige werden auf den neuesten Online Code zur&uuml;ckgef&uuml;hrt (3), und dann zum entfernten Repositorium geschoben (4); dann wird eine Pull Anfrage erstellt, um den Code in das Main-Repositorium einzuf&uuml;gen (5). Dann wird der pers&ouml;nliche Klon mit dem neuen Mastercode aktualisiert (a); dieser aktualisierte Main-Code wird ebenfalls an das Fernrepositorium (b) geschickt, um denselben Code sowohl online als auch offline zu haben.</p>
<p><span id="Branching"></span>
</p>
<h3><span class="mw-headline" id="Verzweigung">Verzweigung</span></h3>
<p>Anstatt an der Main-Version des Codes zu arbeiten, empfiehlt die bew&auml;hrte Methode mit Git die Erstellung eines neuen Zweiges, wann immer du an einer neuen Funktion arbeiten willst. Zweige sind kosteng&uuml;nstig, sie kopieren nicht den gesamten Quellcode Baum, sondern erzeugen lediglich einen Zeitpunkt, an dem Sie Code schreiben werden; daher helfen Zweige dabei, die laufende Arbeit vom Hauptcode getrennt zu halten.
</p><p>Die Verwendung eines neuen Zweigs erfolgt in zwei Schritten: Zuerst erstellest du den Zweig, und dann wechselst du zu ihm:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git branch myNewBranch
git checkout myNewBranch
</pre></div>
<p>F&uuml;hre alternativ beide Schritte mit einer einzigen Anweisung aus:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout -b myNewBranch
</pre></div>
<p>Jetzt kannst du Zweige mit <code>checkout</code> &auml;ndern, wann immer du daran arbeiten musst. Um die Zweige in deinem Projekt und dem aktuellen Zweig zu sehen, verwende die Operation <code>branch</code> allein oder f&uuml;ge <code>-v</code> oder <code>-vv</code> f&uuml;r weitere Informationen hinzu:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git branch
git branch -vv
</pre></div>
<p>Nachdem du &Auml;nderungen vorgenommen und diese &Auml;nderungen &uuml;bertragen hast, verwende die Operation <code>log</code> mit den folgenden Optionen, um die Zweige zu visualisieren
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git log --oneline --decorate --graph --all
</pre></div>
<p><span id="Committing"></span>
</p>
<h3><span id=".C3.9Cbergeben"></span><span class="mw-headline" id="&Uuml;bergeben">&Uuml;bergeben</span></h3>
<p>Sobald du dich in einem neuen Zweig befindest, bearbeite die gew&uuml;nschten Quelldateien mit einem Texteditor. Um zu sehen, welche Dateien ge&auml;ndert wurden, verwende die Operationen <code>status</code> und <code>diff</code>; wenn du mit den &Auml;nderungen zufrieden bist, speichere die &Auml;nderungen mit der Operation <code>commit</code>:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git status
git diff
git commit -a
</pre></div>
<p>Anders als bei SVN muss man ausdr&uuml;cklich angeben, welche Dateien &uuml;bergeben werden; mit der Option <code>-a</code> werden alle ge&auml;nderten Dateien gespeichert. Der voreingestellte Texteditor, z.B. <code>nano</code> oder <code>vim</code>, wird zum Verfassen einer &Uuml;berabemitteilung ge&ouml;ffnet.
</p><p>Alternativ f&uuml;gt man die Mitteilung der &Uuml;bergabeanweisung hinzu:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git commit -a -m "Fix the bug in the clone function."
</pre></div>
<p>Werden neue Dateien oder Verzeichnisse erstellt, muss zuerst die Aktion <code>add</code> ausgef&uuml;hrt werden, die sie zum lokalen Projektarchiv hinzuf&uuml;gt, bevor die &Auml;nderungen &uuml;bergeben werden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git add path
git commit -a
</pre></div>
<p>Wobei <code>path</code> eine beliebige Datei oder ein beliebiges Verzeichnis sein kann.
</p><p><span id="Writing_good_commit_messages"></span>
</p>
<h3><span id="Gute_.C3.9Cbergabemitteilungen_schreiben"></span><span class="mw-headline" id="Gute_&Uuml;bergabemitteilungen_schreiben">Gute &Uuml;bergabemitteilungen schreiben</span></h3>
<p>Man sollte versuchen, in kleinen Schritten zu arbeiten, d. h. h&auml;ufig Commits durchzuf&uuml;hren, nachdem man eine kleine Erg&auml;nzung in dem Code vorgenommen hat. Wenn man die &Auml;nderungen nicht in einem Satz zusammenfassen kann, ist es wahrscheinlich schon zu lange her, dass man einen Commit durchgef&uuml;hrt hat.
</p><p>Bei gr&ouml;&szlig;eren &Auml;nderungen ist es wichtig, dass man hilfreiche und n&uuml;tzliche Beschreibungen der Arbeit bereitstellt. FreeCAD hat ein Format &uuml;bernommen, das im Buch <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2">Pro Git</a> erw&auml;hnt wird und aus einer kurzen Nachricht und einem l&auml;ngeren beschreibenden Absatz besteht.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>Kurze Zusammenfassung der &Auml;nderungen (maximal 50 Zeichen)
 
 Falls erforderlich, f&uuml;gt man einen ausf&uuml;hrlicheren Erl&auml;uterungstext
 hinzu. Man beschr&auml;nkt sich dabei auf etwa 72 Zeichen. In manchen
 Kontexten wird die erste Zeile als Betreff einer E-Mail und der Rest
 des Textes als Hauptteil behandelt. Die Leerzeile zwischen der
 Zusammenfassung und dem Hauptteil ist entscheidend (es sei denn,
 man l&auml;sst den Hauptteil ganz weg); Werkzeuge wie rebase k&ouml;nnen
 verwirrt werden, wenn man beides zusammen ausf&uuml;hrt.
 
 Weitere Abs&auml;tze folgen nach Leerzeilen. 
 
  - Aufz&auml;hlungspunkte sind auch in Ordnung.
 
  - Typischerweise wird f&uuml;r den Aufz&auml;hlungspunkt ein Bindestrich oder
    Sternchen verwendet, dem ein einzelnes Leerzeichen vorangestellt
    ist, mit Leerzeilen dazwischen, aber die Konventionen variieren hier.
</pre></div>
<p>Wenn in einem Branch viele verwandte Arbeiten ausgef&uuml;hrt werden, sollten viele kleine Commits vorgenommen werden (siehe einen  <a rel="nofollow" class="external text" href="https://forum.freecad.org/viewtopic.php?f=10&amp;t=2062&amp;p=14887#p14886">Beitrag im Forum</a>). Wenn diese &Auml;nderungen in den Hauptzweig eingef&uuml;gt werden sollen, sollten folgende Befehle ausgef&uuml;hrt werden:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git log main..myNewBranch
</pre></div>
<p>um die einzelnen &Uuml;bergabe Meldungen zu sehen. Dann kannst du eine Nachricht von hoher Qualit&auml;t schreiben, wenn eine Zusammenf&uuml;hrung durchgef&uuml;hrt wird.
</p><p>Wenn man mit dem Hauptzweig zusammenf&uuml;hrt, verwendet man die Option <code>--squash</code> und f&uuml;hrt einen Commit mit der Qualit&auml;ts-Commit-Meldung durch. So kann man sehr gro&szlig;z&uuml;gig mit den Commits umgehen und die Commit-Meldungen detailliert gestalten, ohne zu viele unterschiedliche Beschreibungen zu verwenden.
</p><p><span id="Squashing_commits"></span>
</p>
<h3><span id="Commits_zusammenf.C3.BChren"></span><span class="mw-headline" id="Commits_zusammenf&uuml;hren">Commits zusammenf&uuml;hren</span></h3>
<p>Squashing bezeichnet den Vorgang, bei dem mehrere aufeinanderfolgende Commits zu einem einzigen zusammengefasst werden. Dies kann sinnvoll sein, wenn man viele kleine Commits vorgenommen hat, die man als einen einzigen Commit pr&auml;sentieren m&ouml;chte, beispielsweise wenn man eine einzelne Variable ge&auml;ndert, Rechtschreibfehler korrigiert und die Abst&auml;nde im Code angepasst hat. Man sollte nur kleine Commits zu einer einzigen Datei zusammenfassen; gr&ouml;&szlig;ere &Auml;nderungen am Code, die sich &uuml;ber mehrere Dateien erstrecken, sollten die vollst&auml;ndige Commit-Historie enthalten.
</p><p>Mit <code>git log --oneline</code> kann man viele Commits nacheinander anzeigen, wobei der neueste Commit ganz oben steht. In diesem Beispiel werden ausgehend von &bdquo;Feature A&ldquo; viele Commits vorgenommen, um &bdquo;Feature B&ldquo; zu implementieren. Wir m&ouml;chten alle Commits, die zu &bdquo;Feature B&ldquo; geh&ouml;ren, zu einem einzigen zusammenfassen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>871adb OK, feature B is fully implemented
1c3317 Whoops, it is not ready yet...
87871a I'm almost ready!
643d0e Code cleanup
af2581 Fix this and that
4e9baa Good implementation
d94e78 Prepare the module for feature B
6394da Feature A
</pre></div>
<p>Den Befehl <code>rebase</code> mit der Option <code>--interactive</code> oder <code>-i</code> verwenden, um verschiedene Commits auszuw&auml;hlen und zusammenzufassen. Den Hash des Commits unmittelbar vor dem ersten verwenden, den man zusammenfassen m&ouml;chte, in diesem Fall den, der &bdquo;Feature A&rdquo; entspricht.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git rebase -i 6394da
</pre></div>
<p>(TIPP: Wenn man wei&szlig;, wie viele Commits bearbeiten werden sollen, kann man <code>git rebase -i HEAD~n</code> verwenden, um die letzten <code>n</code> Commits zu bearbeiten.)
</p><p>Der Befehlszeilen-Editor, wie <code>nano</code> oder <code>vim</code>, &ouml;ffnet sich und zeigt erneut die Commits an, wobei nun der &auml;ltere Commit oben steht. Vor jedem Commit wird das Wort <code>pick</code> angezeigt. Das Wort <code>pick</code> l&ouml;schen und stattdessen das Wort <code>squash</code> oder nur den Buchstaben <code>s</code> schreiben, mit Ausnahme des ersten Eintrags; dieser Commit ist der &auml;lteste, sodass alle zuk&uuml;nftigen Commits darin zusammengefasst werden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>pick d94e78 Prepare the module for feature B
s 4e9baa Good implementation
s af2581 Fix this and that
s 643d0e Code cleanup
s 87871a I'm almost ready!
s 1c3317 Whoops, it is not ready yet...
s 871adb OK, feature B is fully implemented
</pre></div>
<p>Die Datei speichern und den Editor schlie&szlig;en.
</p><p>Der Editor wird erneut ge&ouml;ffnet. Jetzt kann man eine l&auml;ngere Nachricht hinzuf&uuml;gen, die alle &Auml;nderungen so beschreibt, als w&auml;ren sie ein einziger Commit. Die Datei speichern und den Editor erneut schlie&szlig;en. Damit sind diese Commits zu einem einzigen Commit mit der verfassten neuen Commit-Nachricht zusammengefasst.
</p><p>Man kann erneut <code>git log --oneline</code> verwenden, um den neuen Commit-Verlauf anzuzeigen. In diesem Fall wird nur ein einziger Commit f&uuml;r &bdquo;Feature B&ldquo; angezeigt, und zwar &uuml;ber dem unver&auml;nderten Commit f&uuml;r &bdquo;Feature A&ldquo;.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>c83d67 OK, feature B is fully implemented now, with proper module setup, and clean code.
6394da Feature A
</pre></div>
<p>Wenn man f&uuml;r FreeCAD programmiert, bitten wir darum, jede Commit-Meldung mit dem Modul zu beginnen, das davon betroffen ist. Eine Commit-Meldung f&uuml;r eine &Auml;nderung am Sketcher k&ouml;nnte beispielsweise lauten:
</p>
<pre>Sketcher: gerade Linien etwas kr&uuml;mmen

Gerade Linien sind irgendwie h&auml;sslich, daher f&uuml;gt dieser Commit ihnen ein wenig Kr&uuml;mmung hinzu, damit sie optisch ansprechender sind. Sie funkeln auch ein wenig und &auml;ndern mit der Zeit ihre Farbe.

Behebt Fehler #1234.
</pre>
<p>Der Pull Request l&auml;sst sich leichter &uuml;berpr&uuml;fen und schneller zusammenf&uuml;hren, wenn man darauf achten, die Commits vor dem Einreichen mit Rebase zu strukturieren und zu beschreiben.
</p><p><span id="Pushing_your_work_to_your_GitHub_repository"></span>
</p>
<h3><span id="Die_Arbeit_in_das_GitHub-Repository_.C3.BCbertragen"></span><span class="mw-headline" id="Die_Arbeit_in_das_GitHub-Repository_&uuml;bertragen">Die Arbeit in das GitHub-Repository &uuml;bertragen</span></h3>
<p>Die lokalen Branches auf dem Computer werden nicht automatisch mit den Remote-Servern synchronisiert, die man als <code>origin</code> oder <code>upstream</code> angegeben hat (siehe <a href="#Remote_repositories">Remote-Repositorys</a>); Man muss die Branches explizit auf die Remote-Server &uuml;bertragen, f&uuml;r die man Schreibzugriff haben muss. Sobald man dies getan hat, werden die Branches &ouml;ffentlich und k&ouml;nnen von anderen Entwicklern &uuml;berpr&uuml;ft werden.
</p><p>F&uuml;r FreeCAD sollte man den lokalen Zweig in das Remote-Repository <code>origin</code> &uuml;bertragen, d. h. <code>https://github.com/GITHUB_USERNAME/FreeCAD</code>. Man muss bei jedem Push den Benutzernamen und das Passwort eingeben, es sei denn, man hat <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage#_credential_caching">Credential Caching</a> eingerichtet. Weitere Informationen findet man unter <a rel="nofollow" class="external text" href="https://help.github.com/articles/pushing-to-a-remote/">Commits an ein Remote-Repository &uuml;bertragen</a>.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git push origin myNewBranch
</pre></div>
<p>Wenn man mit einem einzelnen Branch arbeitet, muss man m&ouml;glicherweise mehrmals interaktiv Rebase, Squash und Fix Commits durchf&uuml;hren. In diesem Fall ist der Branch-Verlauf nicht einfach und man kann ihn nicht in das Remote-Repository pushen. M&ouml;glicherweise erh&auml;lt man eine Meldung wie die folgende, die besagt, dass ein &bdquo;Fast-Forward&rdquo;-Push nicht m&ouml;glich ist.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>error: failed to push some refs to 'https://github.com/USER/FreeCAD.git'
hint: Updates were rejected because a pushed branch tip is behind its remote
hint: counterpart. Check out this branch and integrate the remote changes
hint: (e.g. 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</pre></div>
<p>Um den Branch endg&uuml;ltig in das Remote-Repository zu &uuml;bertragen, muss man einen &bdquo;Force Push&ldquo; durchf&uuml;hren. Dadurch wird der Remote-Branch vollst&auml;ndig mit dem aktuellen Branch &uuml;berschrieben, den man offline hat.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git push -f origin myNewBranch
</pre></div>
<p>Der regul&auml;re Entwickler hat keinen Schreibzugriff auf das <code>upstream</code>-Repository <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD">https://github.com/FreeCAD/FreeCAD</a></code>, daher sollte man niemals Code auf diesen Remote-Server &uuml;bertragen.
</p><p><span id="Rebasing_from_upstream"></span>
</p>
<h3><span class="mw-headline" id="Rebasing_aus_dem_Upstream">Rebasing aus dem Upstream</span></h3>
<p>W&auml;hrend man am eigenen Zweig arbeitet, entwickelt sich der offizielle FreeCAD-Code durch Commits anderer Entwickler weiter und weicht somit zunehmend von dem Code ab, den man in seinem pers&ouml;nlichen Fork hat.
</p>
<pre>      .-----A origin/myNewBranch
     / 
-----o-----------Z FreeCAD upstream/main
</pre>
<p>Wenn man bereit ist, den Zweig mit dem Haupt-Repository von FreeCAD zusammenzuf&uuml;hren, muss man daher die eigene Kopie des Repositorys &bdquo;rebasen&rdquo;, damit sie so nah wie m&ouml;glich am offiziellen Repository ist. Weitere Informationen findet man unter <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing">Git Branching &ndash; Rebasing</a>.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout myNewBranch
git pull --rebase upstream main
</pre></div>
<p>Dadurch wird der Code aus dem <code>main</code>-Zweig des <code>upstream</code>-Repositorys (der offiziellen FreeCAD-Quelle) heruntergeladen und mit dem aktuellen Zweig (<code>myNewBranch</code>) zusammengef&uuml;hrt, sodass die &Auml;nderungen &uuml;ber dem neuesten offiziellen Code erscheinen. Wenn niemand dieselben Dateien wie man selbst ge&auml;ndert hat, wird die Zusammenf&uuml;hrung ohne Probleme gelingen. Wenn einige Dateien gleichzeitig von verschiedenen Personen ge&auml;ndert wurden, kann es zu einem Konflikt kommen, der gel&ouml;st werden muss.
</p>
<pre>                  .-----A' origin/myNewBranch
                 /
-----o-----------Z FreeCAD upstream/main
</pre>
<p>Zusammenfassend l&auml;sst sich sagen, dass man sich im entsprechenden Branch befindet, den Upstream-Code rebasen und dann mit dem Push fortfahren muss.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout myNewBranch
git pull --rebase upstream main
git push origin myNewBranch
</pre></div>
<p>Der Befehl <code>pull</code> entspricht einem Befehl <code>fetch</code>, gefolgt von einem Befehl <code>merge</code>. Wenn die Option <code>--rebase</code> verwendet wird, wird anstelle eines einfachen Befehls <code>merge</code> der Befehl <code>rebase</code> ausgef&uuml;hrt.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git pull upstream

git fetch upstream
git merge FETCH_HEAD
</pre></div>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git pull --rebase upstream main

git fetch upstream
git rebase main
</pre></div>
<p><span id="Merging_the_branch_(pull_request)"></span>
</p>
<h3><span id="Zusammenf.C3.BChren_des_Zweigs_.28Branches.29_.28Pull_Request.29"></span><span class="mw-headline" id="Zusammenf&uuml;hren_des_Zweigs_(Branches)_(Pull_Request)">Zusammenf&uuml;hren des Zweigs (Branches) (Pull Request)</span></h3>
<p>Nachdem die &Auml;nderungen lokal committet, den Branch aus dem Upstream-Repository rebased und den Branch online gepusht haben, kann man einen &bdquo;Pull Request&ldquo; initiieren. Ein <a rel="nofollow" class="external text" href="https://help.github.com/articles/about-pull-requests/">Pull Request</a> teilt den Administratoren des offiziellen FreeCAD-Repositorys mit, dass man den neuen Code in dem Branch mit dem offiziellen Code zusammenf&uuml;hren m&ouml;chte.
</p><p>Zusammenfassend sieht der Entwicklungsprozess wie folgt aus:
</p>
<ol><li>FreeCAD forken und eine lokale Kopie dieses Forks erstellen.</li>
<li>Einen Branch auf dem Fork erstellen und zu diesem Branch wechseln.</li>
<li>Programmieren! So viel oder so wenig comitten wie man m&ouml;chte und gute Commit-Meldungen schreiben, um den &Uuml;berblick &uuml;ber die Arbeit zu behalten.</li>
<li>Wenn man mit der Arbeit zufrieden ist, verwendet man <code>git rebase -i HEAD~n</code> (wobei n die Gesamtzahl der Commits ist), um die Commits zu einer logischen Gruppe mit guten Commit-Meldungen zusammenzufassen (jede Meldung sollte mit dem Namen des Moduls beginnen, auf das sie sich bezieht, z. B. &bdquo;Sketcher: gerade Linien etwas kr&uuml;mmen&ldquo;).</li>
<li>GitHub verwenden, um den Code wie unten beschrieben als &bdquo;Pull Request (PR)&rdquo; einzureichen.</li></ol>
<p>Sobald man den Code in das <code>origin</code>-Repository <code>https://github.com/GITHUB_USERNAME/FreeCAD</code> &uuml;bertragen hat, bietet einem GitHub die M&ouml;glichkeit, einen Vergleich durchzuf&uuml;hren und einen Pull-Request f&uuml;r das <code>upstream</code>-Repository zu erstellen. Durch Klicken auf <span class="ButtonTemplate" style="background: #f5f5f5; -moz-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); border: 2px solid #989898; border-radius: 0.3em; padding: 0px 8px 1px 8px; font-weight:normal;color: #202122;">Compare &amp; pull request</span> &ouml;ffnet sich eine Oberfl&auml;che, in der man ausw&auml;hlen kann, welches Repository die &bdquo;Basis&rdquo; und das Ziel der Zusammenf&uuml;hrung ist und welches der &bdquo;Head&rdquo; mit dem zus&auml;tzlichen Code ist. Das System f&uuml;hrt eine schnelle &Uuml;berpr&uuml;fung durch und teilt mit, ob es Konflikte mit den von einem ge&auml;nderten Dateien gibt. Wenn man an Dateien gearbeitet hat, die niemand anderes ge&auml;ndert hat, kann der Branch problemlos zusammengef&uuml;hrt werden. 
</p><p>GitHub zeigt einen Texteditor an, in dem man eine Nachricht mit einer Dokumentation der &Auml;nderungen verfassen kann: Dieser Editor ist bereits mit einer Willkommensnachricht (die man l&ouml;schen kann), einer Checkliste (die man durchgehen sollte) und einer Erinnerung versehen, die &Auml;nderung im Wiki zu dokumentieren, sobald sie akzeptiert wurde. Um die Checkliste zu verwenden, geht man nacheinander alle Punkte durch und &auml;ndert <code>[ ]</code> in <code>[X]</code>, um anzuzeigen, dass man diesen Schritt durchgef&uuml;hrt hat. GitHub zeigt auch die Anzahl der Commits im Branch, die Anzahl der ge&auml;nderten Dateien und eine Ansicht mit den Unterschieden zwischen &bdquo;base&rdquo; und &bdquo;head&rdquo; an, sodass jeder sofort die beabsichtigten &Auml;nderungen sehen kann. Diese noch einmal auf Dinge wie versehentlich hinzugef&uuml;gte Leerzeilen oder umfangreiche Formatierungs&auml;nderungen &uuml;berpr&uuml;fen, die die IDE hinter dem R&uuml;cken vorgenommen hat.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>base repository: FreeCAD/FreeCAD    base: main  &lt;----  head repository: GITHUB_USERNAME/FreeCAD    compare: myNewBranch

Able to merge. These branches can be automatically merged.
</pre></div>
<p>Auf <span class="ButtonTemplate" style="background: #f5f5f5; -moz-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); border: 2px solid #989898; border-radius: 0.3em; padding: 0px 8px 1px 8px; font-weight:normal;color: #202122;">Pull-Anfrage erstellen</span> klicken, um fortzufahren. Es erscheint eine Meldung, dass einige &Uuml;berpr&uuml;fungen am Code durchgef&uuml;hrt werden muss. Dabei handelt es sich um ein System, das FreeCAD automatisch kompiliert und die Unit-Tests ausf&uuml;hrt. Wenn die Tests erfolgreich sind, hat die Pull-Anfrage eine bessere Chance, in den Hauptcode integriert zu werden, andernfalls wird ein Bericht erstellt, in dem die aufgetretenen Fehler aufgef&uuml;hrt sind. Siehe <a rel="nofollow" class="external text" href="https://travis-ci.org/FreeCAD/FreeCAD/pull_requests">FreeCAD-Pull-Anfragen</a>.
</p>
<pre>Some checks haven&rsquo;t completed yet

* continuous-integration/travis-ci/pr Pending &mdash; The Travis CI build is in progress  |Required|
</pre>
<p>Wenn die Tests erfolgreich sind, wird eine Meldung wie die folgende angezeigt
</p><p>Alle Pr&uuml;fungen wurden bestanden.
</p>
<pre>* continuous-integration/travis-ci/pr &mdash; The Travis CI build passed  |Required|
</pre>
<p>Dieser Zweig hat keine Konflikte mit dem Basis-Zweig.
Nur diejenigen mit Schreibzugriff auf dieses Repository k&ouml;nnen Pull-Requests zusammenf&uuml;hren.
</p><p>Jetzt muss man warten, bis die Administratoren den Branch zusammenf&uuml;hren. Man wird benachrichtigt, sobald dies geschehen ist.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>Pull request successfully merged and closed

You&rsquo;re all set &mdash; the GITHUB_USERNAME:myNewBranch branch can be safely deleted.
If you wish, you can also delete your fork of FreeCAD/FreeCAD.
</pre></div>
<p>Wenn man m&ouml;chte, kann man den gerade zusammengef&uuml;hrten Zweig oder sogar den gesamten FreeCAD-Fork l&ouml;schen, da der eigene Code bereits am Ende des Hauptzweigs enthalten ist.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>-----o-----------Z----A' FreeCAD upstream/main
</pre></div>
<p><i>Hinweis:</i> Man Kann w&auml;hrend man auf die Genehmigung der Zusammenf&uuml;hrung wartet, weiter an demselben Zweig arbeiten (<code>git commit -a</code>). Wenn man erneut <code>git push</code> ausf&uuml;hrt, wird ein zweiter Zusammenf&uuml;hrungs-Commit in derselben Pull-Anfrage in die Warteschlange gestellt und ein weiterer automatisierter Test durchgef&uuml;hrt. Das hei&szlig;t, solange die Zusammenf&uuml;hrungen noch nicht von den Administratoren genehmigt wurden, kann man weiterhin &Auml;nderungen an dem <code>origin</code>-Repository vornehmen, wodurch diese Commits in derselben Pull-Anforderung an das <code>upstream</code>-Repository in die Warteschlange gestellt werden. Bei kleinen &Auml;nderungen ist es oft w&uuml;nschenswert, viele einzelne Commits mit einer einzigen Pull-Anforderung in die Warteschlange zu stellen. F&uuml;r umfangreiche Erg&auml;nzungen zum Quellcode sollte man einen weiteren Branch erstellen, die Funktionen dort entwickeln und dann einen separaten Pull-Request f&uuml;r diesen Branch einreichen.
</p><p>Die Pull-Request-Schnittstelle kann immer dann verwendet werden, wenn man Code aus den eigenen Repositorys an ein anderes Repository in GitHub &uuml;bermitteln m&ouml;chte. Man kann sie auch verwenden, um Code in die umgekehrte Richtung zusammenzuf&uuml;hren, d. h. von den Branches anderer Personen zu dem eigenen oder sogar zwischen den eigenen Branches. Im letzten Fall kann man die Zusammenf&uuml;hrungen sofort selbst genehmigen, da man selbst der Eigent&uuml;mer der Branches ist.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>base repository: SomeProject/Some_Software  base: main       &lt;----  head repository: GITHUB_USERNAME/Some_Software  compare: add_new_functions
base repository: GITHUB_USERNAME/FreeCAD    base: myNewBranch  &lt;----  head repository: FreeCAD/FreeCAD                compare: main
base repository: GITHUB_USERNAME/FreeCAD    base: myNewBranch  &lt;----  head repository: GITHUB_USERNAME/FreeCAD        compare: fix-many-bugs-branch
</pre></div>
<p><span id="Keeping_the_GitHub_repository_up_to_date"></span>
</p>
<h3><span class="mw-headline" id="Das_GitHub_Repositorium_auf_dem_neuesten_Stand_halten">Das GitHub Repositorium auf dem neuesten Stand halten</span></h3>
<p>Sobald man FreeCAD geforkt hat, existiert das pers&ouml;nliche Repository unabh&auml;ngig vom Original. Wenn das urspr&uuml;ngliche Repository neue Commits enth&auml;lt, informiert GitHub einen dar&uuml;ber, dass das pers&ouml;nliche Repository hinsichtlich der Anzahl der Commits hinterherhinkt:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>This branch is 5 commits behind FreeCAD:main.
</pre></div>
<p>In &auml;hnlicher Weise informiert GitHub einen, wenn man einen Entwicklungszweig mit neuem Code erstellt hat, dass dieser Zweig in der Anzahl der Commits voraus ist, d. h., dieser Zweig enth&auml;lt &Auml;nderungen, die noch nicht in das offizielle FreeCAD-Repository &uuml;bernommen wurden:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>This branch is 3 commits ahead of FreeCAD:main.
</pre></div>
<p>W&auml;hrend der Entwicklung sind beide F&auml;lle m&ouml;glich, da der eigene Branch m&ouml;glicherweise keine Commits anderer Entwickler enth&auml;lt, aber neue Commits von einem enth&auml;lt:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>This branch is 2 commits ahead, 14 commits behind FreeCAD:main.
</pre></div>
<p>Bei der Entwicklung von Code wird empfohlen, den Zweig, an dem man gerade arbeitet, neu zu rebasen, da der Zweig dadurch immer vor dem FreeCAD-Hauptcode bleibt.
</p><p>Was den urspr&uuml;nglichen <code>main</code>-Zweig betrifft, so wird dieser niemals automatisch von GitHub aktualisiert; dies muss man selbst tun. Zum <code>main</code>-Zweig wechseln, dann <code>pull</code> von <code>upstream</code> ausf&uuml;hren (wodurch <code>fetch</code> und <code>merge</code> ausgef&uuml;hrt werden) und diesen aktualisierten <code>main</code>-Zweig dann in das Remote-Repository <code>origin</code> &uuml;bertragen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout main
git pull upstream main
git push origin main
</pre></div>
<p>Nachdem dies erledigt ist, teilt GitHub mit, dass man mit dem <code>upstream</code>-Repository synchronisiert ist.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>This branch is even with FreeCAD:main.
</pre></div>
<p>Nachdem der <code>main</code> nun auf dem neuesten Stand ist, kann man zu diesem wechseln und den anderen Zweig l&ouml;schen, den man zuvor zur Entwicklung einer Funktion verwendet hat.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout main
git branch -d myNewBranch
</pre></div>
<p>Um den Branch im Remote-Repository <code>origin</code> zu l&ouml;schen, kann man den Befehl <code>push</code> verwenden. Normalerweise pusht man einen lokalen Zweig; dadurch wird ein Remote-Zweig mit dem gleichen Namen wie der lokale Zweig erstellt.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git push origin myNewBranch
</pre></div>
<p>Wenn jedoch die Notation <code>local_name:remote_name</code> verwendet wird, wird der lokale Zweig im Remote-Repository unter einem anderen Namen erstellt:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git push origin myNewBranch:someRemoteBranch
</pre></div>
<p>Daher kannst du den entfernte Fernzweig l&ouml;schen, indem du einen leeren lokale Zweig schiebst:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git push origin :myNewBranch
git push origin :someRemoteBranch
</pre></div>
<p>Da man nun nur noch &uuml;ber ein aktuelles <code>main</code> verf&uuml;gt, kann man einen neuen Zweig erstellen und die Schritte zum &Auml;ndern von Dateien, Committen, Pushen, Einreichen eines Pull-Request, Zusammenf&uuml;hren und Aktualisieren wiederholen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout main
git checkout -b anotherBranch
</pre></div>
<p>Wenn man den bereits benutzerdefinierten Branch nicht l&ouml;schen m&ouml;chte, kann man eine Aktualisierung erzwingen, sodass er mit dem aktualisierten <code>main</code> &uuml;bereinstimmt. Anschlie&szlig;end kann man damit tun, was man m&ouml;chte, einschlie&szlig;lich weiterer Commits hinzuf&uuml;gen und ihn in das Remote-Repository <code>origin</code> pushen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout myNewBranch
git reset --hard main
git push -f origin myNewBranch
</pre></div>
<p>Ein solches hartes Zur&uuml;cksetzen eines Branches ist in der Regel nicht erforderlich. In den meisten F&auml;llen sollten man die Reihenfolge befolgen: Einen neuen Branch erstellen, die &Auml;nderungen committen, diese &Auml;nderungen pushen, den Zweig mergen und ihn anschlie&szlig;end l&ouml;schen.
</p><p><span id="Advanced_Git_operations"></span>
</p>
<h2><span class="mw-headline" id="Erweiterte_Git_Operationen">Erweiterte Git Operationen</span></h2>
<p><span id="Searching"></span>
</p>
<h3><span class="mw-headline" id="Suchen">Suchen</span></h3>
<p>Einige praktische Werkzeuge, die einem bei der Suche helfen:
</p><p><span id="Search_filenames"></span>
</p>
<h4><span class="mw-headline" id="Dateinamen_suchen">Dateinamen suchen</span></h4>
<p><code>git ls-files</code> verwenden, um das Repository nach Dateien zu durchsuchen, deren Dateiname eine bestimmte Zeichenfolge enth&auml;lt. Das folgende Beispiel gibt alle Dateien zur&uuml;ck, deren Dateiname die Zeichenfolge 'dxf' enth&auml;lt.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git ls-files *dxf*
</pre></div>
<p><br>
<span id="Search_for_a_string"></span>
</p>
<h4><span class="mw-headline" id="Suche_nach_einer_Zeichenkette">Suche nach einer Zeichenkette</span></h4>
<p><code>git grep</code> verwenden, um das Repository nach Dateien zu durchsuchen, die eine bestimmte Zeichenfolge enthalten. Das folgende Beispiel gibt alle Instanzen der Dateien zur&uuml;ck, die die Zeichenfolge 'dxf' enthalten.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git grep dxf
</pre></div>
<p><br>
<span id="Resolving_merge_conflicts"></span>
</p>
<h3><span id="Aufl.C3.B6sen_von_Zusammenf.C3.BChrungskonflikten"></span><span class="mw-headline" id="Aufl&ouml;sen_von_Zusammenf&uuml;hrungskonflikten">Aufl&ouml;sen von Zusammenf&uuml;hrungskonflikten</span></h3>
<p>Das Zusammenf&uuml;hren von Branches mit <code>git merge</code> oder das Rebasing des Branches mit <code>git rebase</code> f&uuml;hrt gelegentlich zu Konflikten, da Dateien m&ouml;glicherweise gleichzeitig von einem anderen Autor ge&auml;ndert wurden. In diesem Fall sollte man sich die &Auml;nderungen beider Seiten, die des anderen Autors und die eigenen, ansehen und dann entscheiden, wie man beide &Auml;nderungss&auml;tze bestm&ouml;glich einarbeiten kann. Dies ist in der Regel ein manueller Prozess, der nicht automatisiert werden kann. Der Programmierer muss den Code verstehen und entscheiden, welcher Code verschoben, umgeschrieben oder entfernt werden muss, um den Konflikt zu l&ouml;sen.
</p><p>Sobald ein Konflikt auftritt, kann eine Meldung wie diese erscheinen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>CONFLICT (content): Merge conflict in src/Mod/source_code.py
error: Failed to merge in the changes.
Patch failed at 1234 Some commit message when editing source_code.py
</pre></div>
<p>Wenn ein spezielles Diff-Tool f&uuml;r Git installiert und konfiguriert ist, beispielsweise Gnome's <a rel="nofollow" class="external text" href="https://wiki.gnome.org/Apps/Meld">Meld</a>, kann der Konflikt mithilfe der Operation <code>mergetool</code> untersucht und gel&ouml;st werden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git mergetool
</pre></div>
<p>Das Meld-Tool zeigt normalerweise drei Spalten an: Die beiden seitlichen Spalten zeigen die beiden in Konflikt stehenden Dateien an, w&auml;hrend die mittlere Spalte den neuen Code anzeigt, der schlie&szlig;lich gespeichert und committet wird. Daher sollte diese mittlere Spalte so bearbeitet werden, dass sie den Code beider seitlichen Spalten integriert. Sobald der Konflikt gel&ouml;st und der neue Quellcode (die mittlere Spalte) gespeichert ist, kann das Meld-Tool geschlossen werden. Dann kann der Vorgang <code>merge</code> oder <code>rebase</code> fortgesetzt werden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git merge --continue
git rebase --continue
</pre></div>
<p>Weitere Informationen zum Zusammenf&uuml;hren und L&ouml;sen von Konflikten finden Sie unter:
</p>
<ul><li><a rel="nofollow" class="external text" href="https://git-scm.com/docs/git-merge#_how_conflicts_are_presented">How merge conflicts are presented</a> mit <code>git merge</code>.</li>
<li><a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#_basic_merge_conflicts">Basic merge conflicts</a> und <a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging">Git Tools - Advanced Merging</a>.</li>
<li><a rel="nofollow" class="external text" href="https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/">Resolving a merge conflict using the command line</a>.</li>
<li><a rel="nofollow" class="external text" href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_external_merge_tools">External merge and diff tools</a> zu verwenden, wenn man auf einen Git-Konflikt st&ouml;&szlig;t.</li></ul>
<p><span id="Inspect_changes"></span>
</p>
<h3><span id=".C3.84nderungen_untersuchen"></span><span class="mw-headline" id="&Auml;nderungen_untersuchen">&Auml;nderungen untersuchen</span></h3>
<p>Den Verlauf einer einzelnen Datei anhand verschiedener Commits mit dem Befehl <code>log</code> &uuml;berpr&uuml;fen:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git log --patch path
</pre></div>
<p>Wobei <code>path</code> ein beliebiges Verzeichnis oder eine beliebige Datei sein kann. Anstelle von <code>--patch</code> k&ouml;nnen auch die Kurzformen <code>-p</code> oder <code>-u</code> verwendet werden.
</p><p><span id="Inspect_changes_between_two_branches"></span>
</p>
<h3><span id=".C3.84nderungen_zwischen_zwei_Zweigen_untersuchen"></span><span class="mw-headline" id="&Auml;nderungen_zwischen_zwei_Zweigen_untersuchen">&Auml;nderungen zwischen zwei Zweigen untersuchen</span></h3>
<p>Die &Auml;nderungen zwischen zwei Zweigen mit den Operationen <code>log</code> und <code>diff</code> unter Angabe der Namen der Zweige &uuml;berpr&uuml;fen:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git log main..myBranch
git diff main..myBranch
</pre></div>
<p>Der Befehl <code>log</code> zeigt die Commits an, w&auml;hrend <code>diff</code> die tats&auml;chlichen &Auml;nderungen in den Dateien anzeigt.
</p><p><span id="Reset_files_and_directories"></span>
</p>
<h3><span id="Dateien_und_Verzeichnisse_zur.C3.BCcksetzen"></span><span class="mw-headline" id="Dateien_und_Verzeichnisse_zur&uuml;cksetzen">Dateien und Verzeichnisse zur&uuml;cksetzen</span></h3>
<p>Wenn man versehentlich &Auml;nderungen an einer Datei oder einem Verzeichnis vorgenommen hat, m&ouml;chte man diese &Auml;nderungen m&ouml;glicherweise vollst&auml;ndig r&uuml;ckg&auml;ngig machen, um den vorherigen Zustand des Quellcodes wiederherzustellen.
</p><p>Dies kann schnell mit der Operation <code>checkout</code> durchgef&uuml;hrt werden:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout path
git checkout .
</pre></div>
<p>Dadurch wird <code>path</code> (eine Datei oder ein Verzeichnis) in den Zustand am Anfang des Zweigs zur&uuml;ckgesetzt, wobei nicht festgeschriebene &Auml;nderungen verworfen werden. Wenn <code>path</code> der einzelne Punkt <code>.</code> ist, werden alle Dateien im aktuellen Verzeichnis wiederhergestellt.
</p><p>Wenn man versehentlich Dateien und Verzeichnisse hinzugef&uuml;gt hat, kann man den Befehl <code>clean</code> verwenden:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git clean -df
</pre></div>
<p>Dadurch werden alle Dateien und Verzeichnisse (<code>-df</code>) gel&ouml;scht, die nicht vom Repository verfolgt werden, d. h. diejenigen, die zuvor nicht mit dem Befehl <code>add</code> hinzugef&uuml;gt wurden.
</p><p>Um das Repository vollst&auml;ndig zur&uuml;ckzusetzen und alle nicht festgeschriebenen &Auml;nderungen zu verlieren, verwendet man den Befehl <code>reset</code>:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git fetch
git reset --hard FETCH_HEAD
</pre></div>
<p>Wobei <code>FETCH_HEAD</code> die Spitze des <code>upstream</code>-Repositorys ist. Es kann auch ein anderer Commit verwendet werden.
</p><p>Der Befehl <code>revert</code> macht ebenfalls &Auml;nderungen r&uuml;ckg&auml;ngig. Allerdings f&uuml;gt dieser Befehl dazu einen weiteren Commit zur Historie hinzu, was in vielen F&auml;llen nicht erw&uuml;nscht ist.
</p><p><span id="Pruning_old_branches"></span>
</p>
<h3><span class="mw-headline" id="Beschneiden_alter_Zweige">Beschneiden alter Zweige</span></h3>
<p>Wenn man viele Branches in das <code>upstream</code>-Repository &uuml;bertragen hat, m&ouml;chten man diese Branches m&ouml;glicherweise aus dem lokalen System entfernen, da sie bereits zusammengef&uuml;hrt wurden. Der Zweig im Online-Repository <code>origin</code> kann unmittelbar nach dem Zusammenf&uuml;hren gel&ouml;scht werden. Anschlie&szlig;end kann man die lokalen Verweise auf diesen Zweig entfernen, indem man die Optionen <code>--prune</code> oder <code>prune</code> f&uuml;r die Operationen <code>fetch</code> und <code>remote</code> verwenden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git fetch --prune origin
git remote prune origin
</pre></div>
<p>Schlie&szlig;lich kannst du die Zweige lokal l&ouml;schen
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git branch -D myBranch
</pre></div>
<p>Es empfiehlt sich au&szlig;erdem, nach einer Weile eine Garbage Collection durchzuf&uuml;hren, indem man den Befehl <code>gc</code> verwendet. Dadurch werden unn&ouml;tige Dateien bereinigt und lokale Dateirevisionen komprimiert, um die lokale Festplattennutzung des Repositorys zu optimieren.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git gc
</pre></div>
<p><span id="Working_with_patches"></span>
</p>
<h3><span class="mw-headline" id="Arbeiten_mit_Patches">Arbeiten mit Patches</span></h3>
<p>Obwohl Git Ihnen dir erlaubt, verschiedene Code Zweige mit <code>git merge</code> zusammenzuf&uuml;hren (in deinem Computer) oder einer Pull Anfrage (Fernrepositorium) gibt es Zeiten, in denen es w&uuml;nschenswert sein kann, einen traditionellen "Patch" zu erstellen, der als Anhang per Email verschickt werden kann. Der folgende Arbeitsablauf erkl&auml;rt, wie dies zu tun ist.
</p><p><span id="Creating_patches"></span>
</p>
<h4><span class="mw-headline" id="Patches_erstellen">Patches erstellen</span></h4>
<ul><li>Man sollte den neuen Code in einem sekund&auml;ren Zweig des Repositorys entwickeln, nicht im Hauptzweig. Der erste Schritt besteht also darin, sicherzustellen, dass man sich im richtigen Zweig befindet.</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git branch -v
git checkout myBranch
</pre></div>
<ul><li>Nun verwendet man <code>git format-patch</code> f&uuml;r den Hauptzweig und verwendet die Option <code>--stdout</code>, um das Ergebnis an die Standardausgabe umzuleiten. Dann die Standardausgabe in eine Datei umleiten, die der Einfachheit halber &uuml;ber dem Quellcodeverzeichnis erstellt wird.</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git format-patch main --stdout &gt; ../myCode.patch
</pre></div>
<ul><li>Eine andere Methode ist</li></ul>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git format-patch HEAD^
git format-patch HEAD~1
</pre></div>
<p>Die Anzahl der Zirkumflex-Zeichen <code>^</code> oder die Zahl <code>1</code> geben die Anzahl der zu ber&uuml;cksichtigenden Commits an, d. h. <code>^^^</code> oder <code>~3</code> erstellt drei Patches f&uuml;r drei Commits.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git format-patch HEAD^
</pre></div>
<p>Dadurch wird ein Patch oder eine Reihe von Patches mit der folgenden Namenskonvention erstellt
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>XXXX-commit-message.patch
</pre></div>
<p>wobei <code>XXXX</code> eine Zahl zwischen <code>0000</code> und <code>9999</code> ist und die Commit-Nachricht den gr&ouml;&szlig;ten Teil des Dateinamens ausmacht, zum Beispiel
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>0001-fix-ViewProjMatrix-getProjectionMatrix.patch
</pre></div>
<p><span id="Applying_patches"></span>
</p>
<h4><span class="mw-headline" id="Patches_anwenden">Patches anwenden</span></h4>
<p>Git kann Patches oder Diffs zusammenf&uuml;hren. Weitere Informationen zu diesem Vorgang findet man unter <a rel="nofollow" class="external text" href="https://www.drupal.org/node/1399218">Patches mit Git anwenden</a>.
</p><p>Wenn du die Patch Datei bereits in deinem System hast, wende sie einfach an.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git apply myCode.patch
</pre></div>
<p>Man kann <code>curl</code> verwenden, um einen Patch von einer Website herunterzuladen, und ihn dann &uuml;ber <code>git</code> anwenden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>curl -O https://some.website.org/code/myCode.patch
git apply myCode.patch
</pre></div>
<p><code>.diff</code> oder <code>.patch</code> am Ende der URL eines GitHub-Commits, Pull-Requests oder Vergleichsansicht hinzuf&uuml;gen, damit die Website die Nur-Text-Ansicht dieser Seite anzeigt.
</p>
<ul><li>Normale Commit-Seite: <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD/commit/c476589652a0f67b544735740e20ff702e8d0621">https://github.com/FreeCAD/FreeCAD/commit/c476589652a0f67b544735740e20ff702e8d0621</a></code></li>
<li>Diff-Seite: <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD/commit/c476589652a0f67b544735740e20ff702e8d0621.diff">https://github.com/FreeCAD/FreeCAD/commit/c476589652a0f67b544735740e20ff702e8d0621.diff</a></code></li>
<li>Patch-Seite: <code><a rel="nofollow" class="external free" href="https://github.com/FreeCAD/FreeCAD/commit/c476589652a0f67b544735740e20ff702e8d0621.patch">https://github.com/FreeCAD/FreeCAD/commit/c476589652a0f67b544735740e20ff702e8d0621.patch</a></code></li></ul>
<p>Man kann <code>curl</code> auf einen bestimmten Commit-Patch im Repository verweisen und ihn direkt an <code>git</code> weiterleiten, um den Patch anzuwenden.
</p>
<pre>curl https://github.com/FreeCAD/FreeCAD/commit/c476589652a0f67b544735740e20ff702e8d0621.patch | git apply -
</pre>
<p><span id="Reversing_a_patch"></span>
</p>
<h4><span id="Einen_Patch_r.C3.BCckg.C3.A4ngig_machen"></span><span class="mw-headline" id="Einen_Patch_r&uuml;ckg&auml;ngig_machen">Einen Patch r&uuml;ckg&auml;ngig machen</span></h4>
<p>Wenn man einen Patch anwendet, werden einige Dateien ge&auml;ndert. Diese &Auml;nderungen sind jedoch erst dann dauerhaft, wenn man die &Auml;nderungen festschreibt. Wenn man einen Patch r&uuml;ckg&auml;ngig machen m&ouml;chte, befolgen man daher die folgenden Anweisungen.
</p><p>Dadurch werden die vorgenommenen &Auml;nderungen r&uuml;ckg&auml;ngig gemacht, sofern noch Zugriff auf die urspr&uuml;ngliche Patch-Datei besteht.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git apply -R myCode.patch
</pre></div>
<p>Alternativ werden dadurch nicht festgeschriebene &Auml;nderungen an dem Zweig entfernt.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout -f
</pre></div>
<p><span id="Stashing_git_commits"></span>
</p>
<h3><span id="Git-Commits_zwischenspeichern_.28stashing.29"></span><span class="mw-headline" id="Git-Commits_zwischenspeichern_(stashing)">Git-Commits zwischenspeichern (stashing)</span></h3>
<p>Angenommen, man arbeiten an einem Branch und nimmt einige &Auml;nderungen an der Quelle vor, die au&szlig;erhalb des Umfangs des aktuellen Branches liegen. Mit anderen Worten: Diese &Auml;nderungen w&auml;ren besser in einem anderen Branch als dem aktuellen aufgehoben. Mit dem Befehl <code>git stash</code> kann man diese nicht festgeschriebenen lokalen &Auml;nderungen vor&uuml;bergehend speichern.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git stash
</pre></div>
<p>Wenn man diese Commits in Zukunft verwenden m&ouml;chte, kann man die Commits aus dem Zwischenspeicher (Stash) in den Arbeitszweig &bdquo;herausholen&ldquo;.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git stash pop
</pre></div>
<p>Wenn man feststellt, dass einem die gespeicherten Commits nicht mehr gefallen, kann man die Commits vollst&auml;ndig aus dem Stash l&ouml;schen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git stash drop
</pre></div>
<p>Man kann mehrere Stash-Commits mit
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git stash list
</pre></div>
<p>Weitere Informationen findet man unter <a rel="nofollow" class="external text" href="https://medium.freecodecamp.org/useful-tricks-you-might-not-know-about-git-stash-e8a9490f0a1a">N&uuml;tzliche Tricks, die man vielleicht noch nicht &uuml;ber Git Stash wei&szlig;</a>.
</p><p><span id="Check_out_GitHub_requests_locally"></span>
</p>
<h3><span class="mw-headline" id="GitHub_Anfragen_lokal_herausfinden">GitHub Anfragen lokal herausfinden</span></h3>
<p><a rel="nofollow" class="external text" href="https://gist.github.com/piscisaureus/3342247">GitHub-Pull-Anfragen lokal &uuml;berpr&uuml;fen</a>
</p><p><br>
<span id="Blame_feature"></span>
</p>
<h3><span class="mw-headline" id="Blame-Funktion">Blame-Funktion</span></h3>
<p>Die Blame-Funktion auf GitHub ist n&uuml;tzlich, um herauszufinden, welcher Commit jede einzelne Codezeile eingef&uuml;hrt oder zuletzt ge&auml;ndert hat. Um sie zu aktivieren, wechselt man beim Anzeigen einer Datei von der Registerkarte Code zur Registerkarte Blame oder w&auml;hlt eine bestimmte Zeile aus (auf deren Nummer klicken), die Taste <span class="ButtonTemplate" style="background: #f5f5f5; -moz-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); border: 2px solid #989898; border-radius: 0.3em; padding: 0px 8px 1px 8px; font-weight:normal;color: #202122;">...</span> dr&uuml;cken und <i>View git blame</i> w&auml;hlen. Weitere Informationen zur Blame-Funktion findet man in <a rel="nofollow" class="external text" href="https://forum.freecad.org/viewtopic.php?f=23&amp;t=55943&amp;p=481483#p481287">diesem Forumbeitrag</a>. Der zugeh&ouml;rige Git-Befehl ist <a rel="nofollow" class="external text" href="https://git-scm.com/docs/git-blame">hier</a> dokumentiert.
</p><p><span id="Bisect"></span>
</p>
<h3><span id="Halbieren_.28bisect.29"></span><span class="mw-headline" id="Halbieren_(bisect)">Halbieren (bisect)</span></h3>
<p><code>git bisect</code> ist eine Methode, um den spezifischen Commit zu finden, der einen Fehler verursacht hat. 
</p><p>Es m&uuml;ssen zwei Commits gefunden werden:
</p>
<ul><li>Einen guten Commit (z. B. <code>abcd</code>) vor dem Ausfall des Systems.</li>
<li>Einen schlechten Commit (z. B. <code>efgh</code>) nach dem Ausfall des Systems.</li></ul>
<p>Dann Folgendes &uuml;ber das Terminal eingeben:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git bisect start
git bisect good abcd
git bisect bad efgh
</pre></div>
<p>Ergebnis: <code>git</code> checkt den Mittelpunkt zwischen den beiden Commits aus. 
</p><p>Der n&auml;chste Schritt besteht darin, den Code zu erstellen und zu testen. Wenn das System funktioniert, f&auml;hrt man mit der Eingabe von folgendem Befehl fort:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git bisect good
</pre></div>
<p>Den vorherigen Schritt wiederholen, indem man den Code erstellt und testet.
</p><p>Wenn das System defekt ist, gibt man Folgendes ein:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git bisect bad
</pre></div>
<p>Die vorherigen Schritte wiederholen und dabei je nach Ergebnis der Tests <code>good</code> oder <code>bad</code> anwenden.
</p><p>Schlie&szlig;lich wird <code>git</code> mitteilen, dass <code>wxyz</code> der erste fehlerhafte Commit ist.
</p><p>Um den bisect-Prozess zu beenden, gibt man schlie&szlig;lich Folgendes ein:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git bisect reset
</pre></div>
<p>Hinweis: <code>git bisect</code> dauert sehr lange, wenn gute und schlechte Ergebnisse weit auseinander liegen.
</p><p><span id="FreeCAD_revision_number"></span>
</p>
<h2><span class="mw-headline" id="FreeCAD_Revisionsnummer">FreeCAD Revisionsnummer</span></h2>
<p>Im Gegensatz zu Subversion, das f&uuml;r seine Revisionen eine fortlaufende Nummer verwendet, erzeugt Git bei jedem Commit <a rel="nofollow" class="external text" href="https://de.wikipedia.org/wiki/Secure_Hash_Algorithm#SHA-1">SHA-1-Hashwerte</a>. Ein Hashwert ist eine lange alphanumerische Zeichenfolge, die wie folgt aussieht
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>9b3ffef570596e184006287434fba54a4b03ccc3
</pre></div>
<p><span id="Latest_revision_number"></span>
</p>
<h3><span class="mw-headline" id="Letzte_Revisionsnummer">Letzte Revisionsnummer</span></h3>
<p>Um die neueste Revisionsnummer eines bestimmten Branches zu ermitteln, verwendet man den Befehl <code>rev-list</code> mit der Option <code>--count</code>. Gibt den Namen des Branches, des Remote-Repositorys, des Tags oder eines speziellen Zeigers wie <code>HEAD</code> an, um den letzten Commit in diesem bestimmten Objekt anzugeben.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git rev-list --count main
git rev-list --count HEAD
git rev-list --count origin
</pre></div>
<p>Oder man durchsucht <a rel="nofollow" class="external text" href="https://github.com/FreeCAD/FreeCAD">das Repository auf GitHub</a> und liest die Anzahl der Commits, die in dem jeweiligen Branch gemeldet werden.
</p><p><span id="Revision_number_of_a_specific_commit_hash"></span>
</p>
<h3><span class="mw-headline" id="Revisionsnummer_eines_bestimmten_Commit_Hashes">Revisionsnummer eines bestimmten Commit Hashes</span></h3>
<p>Da es sich bei dem Hash um eine alphanumerische Zeichenfolge handelt, ist es nicht sehr sinnvoll, zu entscheiden, ob ein bestimmter Commit &auml;lter oder neuer als ein anderer Hash ist. Um die Revisionsnummer eines bestimmten Hashs zu ermitteln, verwendet man erneut die Operation <code>rev-list</code>. Als Eingabe kann der vollst&auml;ndige Hash oder ein eindeutiger Teil-Hash verwendet werden, wobei in der Regel die ersten 7 Ziffern ausreichen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git rev-list --count ab1520b872821414c6ce4a15fb85d471ac2a2b03
git rev-list --count 9948ee4
</pre></div>
<p><span id="Revision_hash_of_a_specific_commit_number"></span>
</p>
<h3><span class="mw-headline" id="Revisions_Hash_einer_bestimmten_Commit_Nummer">Revisions Hash einer bestimmten Commit Nummer</span></h3>
<p>Wenn wir die Commit-Nummer haben, beispielsweise 15000, und den entsprechenden Hash finden m&ouml;chten, m&uuml;ssen wir die Anzahl der Commits seit diesem Zeitpunkt bis zum letzten Commit (<code>HEAD</code>) berechnen. Zun&auml;chst muss die neueste Commit-Nummer abgerufen werden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git rev-list --count HEAD
17465
</pre></div>
<p>Dann subtrahiert man den gew&uuml;nschten Commit.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>17465 - 15000 = 2465
</pre></div>
<p>Dann den Befehl <code>log</code> verwenden, um alle Commits und Hashes anzuzeigen. Die Option <code>--skip</code> &uuml;berspringt die von uns berechneten Unterschiede zwischen den Commits, sodass wir direkt zu dem gesuchten Hash gelangen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git log --skip=2465
commit 44c2f19e380e76b567d114a6360519d66f7a9e24
</pre></div>
<p>Da das Protokoll m&ouml;glicherweise zwei nahe beieinander liegende Commits anzeigt, &uuml;berpr&uuml;fen, ob es sich um die richtige Commit-Nummer handelt. Wenn sie um eins abweicht, einfach den n&auml;chsten Commit in der Reihenfolge w&auml;hlen (vor oder nach) und erneut &uuml;berpr&uuml;fen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git rev-list --count 44c2f19e38
15000
</pre></div>
<ul><li><a rel="nofollow" class="external text" href="https://forum.freecad.org/viewtopic.php?f=10&amp;t=26673">Show the commits</a> unmittelbar vor einem bestimmten Commit in GitHub: In der Adressleiste des Browsers das Wort <code>commit</code> in <code>commits</code> &auml;ndern, um eine Liste anzuzeigen.</li>
<li><a rel="nofollow" class="external text" href="https://forum.freecad.org/viewtopic.php?t=5308">Finding the revision number of the commit</a></li>
<li><a rel="nofollow" class="external text" href="https://forum.freecad.org/viewtopic.php?f=18&amp;t=12883&amp;p=103207#p103203">Finding the revision number of the commit</a></li>
<li><a rel="nofollow" class="external text" href="https://forum.freecad.org/viewtopic.php?f=10&amp;t=31118">Finding the corresponding hash value to a particular commit number</a></li></ul>
<p><span id="Revision_number_in_FreeCAD's_interface"></span>
</p>
<h3><span id="Revisionsnummer_in_der_FreeCAD_Oberfl.C3.A4che"></span><span class="mw-headline" id="Revisionsnummer_in_der_FreeCAD_Oberfl&auml;che">Revisionsnummer in der FreeCAD Oberfl&auml;che</span></h3>
<p>Die Versionsnummer, die mit dem <a href="../de/Std_About.html" title="Std About/de">Std &Uuml;ber</a> Werkzeug angezeigt wird, ist in <code>src/Build/Version.h</code> definiert, was zur Kompilierzeit erstellt wird, wenn das Werkzeug <code>cmake</code> ausgef&uuml;hrt wird. Lies <a rel="nofollow" class="external text" href="https://forum.freecad.org/viewtopic.php?f=4&amp;t=3025">Versionsnummer aus der Git Quelle extrahieren</a> f&uuml;r weitere Informationen.
</p><p><span id="Adding_other_repositories_(remotes)"></span>
</p>
<h2><span id="Hinzuf.C3.BCgen_weiterer_.28Fern.29_Repositorien"></span><span class="mw-headline" id="Hinzuf&uuml;gen_weiterer_(Fern)_Repositorien">Hinzuf&uuml;gen weiterer (Fern) Repositorien</span></h2>
<p>Mehrere Mitarbeiter des FreeCAD Projekts haben ihre eigenen Git Repositorien, in denen sie ihre Arbeit aufbauen oder neue Ideen ausprobieren, bevor sie bereit sind, in den offiziellen Quellcode aufgenommen zu werden. Vielleicht m&ouml;chtest du ihre Quellen bekommen, um ihren Code selbst zu testen, wenn sie eine Pull Anfrage stellen.
</p><p>Verwende den Befehl  <code>git fern</code> Befehl, um diese anderen Repositorien hinzuzuf&uuml;gen, so dass du deren Code <code>holen</code> und <code>abrufen</code> kannst.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout main
git remote add OTHER_USER OTHER_URL
git fetch OTHER_USER
git checkout -b OTHER_BRANCH OTHER_USER/OTHER_BRANCH
</pre></div>
<p>Lass uns zum Beispiel Bernds Fernrepositorium hinzuf&uuml;gen:
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git remote add bernd http://github.com/berndhahnebach/FreeCAD_bhb
</pre></div>
<p>Der <code>git holen</code> Befehl l&auml;dt die Referenzen von diesem Fernrepositorium herunter.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git fetch bernd
</pre></div>
<p>Liste alle Zweige in deinem eigenen Repositorium und die von deinen hinzugef&uuml;gten Fernen auf. Bernds Zweige werden als <code>Fern/bernd/&lt;Zweigname&gt;</code> angezeigt.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git branch -a
</pre></div>
<p>Lass uns nun eine zusammenfassende Liste der letzten 10 Commits von bernds <code>femdev</code> Zweig ansehen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git log -10 --oneline remotes/bernd/femdev
</pre></div>
<p>Jetzt k&ouml;nnen wir den gew&uuml;nschte Zweig zur Inspektion herausfinden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout remotes/bernd/femdev
</pre></div>
<p>Dann k&ouml;nnen wir einen lokalen Zweig erstellen, der auf dem entfernten Zweig basiert. Diesen lokalen Zweig k&ouml;nnen wir modifizieren und unseren eigenen Code hinzuf&uuml;gen.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git checkout -b local_branch_name /remotes/bernd/femdev
</pre></div>
<p>Du kannst den <code>git rebase</code> des neu erhaltenen Zweigs auf den <code>upstream/main</code> Zweig umstellen, um sicherzustellen, dass er den neuesten Code verwendet. Wenn es Konflikte gibt, m&uuml;ssen diese an diesem Punkt gel&ouml;st werden.
</p>
<div class="mw-highlight mw-highlight-lang-text mw-content-ltr" dir="ltr"><pre><span></span>git pull --rebase upstream main
</pre></div>
<p>Der neue Zweig ist bereit, modifiziert und kompiliert zu werden, wie in <a href="../de/Compiling.html" title="Compiling/de">Kompilieren</a> beschrieben.
</p><p>Besuche die Entwicklungsabteilung des <a rel="nofollow" class="external text" href="https://forum.freecad.org/viewforum.php?f=6">FreeCAD Forum</a>s, um mehr &uuml;ber die Entwicklung zu erfahren.
</p><p><span id="Further_reading"></span>
</p>
<h2><span id="Weiterf.C3.BChrende_Literatur"></span><span class="mw-headline" id="Weiterf&uuml;hrende_Literatur">Weiterf&uuml;hrende Literatur</span></h2>
<ul><li><a href="../de/Developing_FreeCAD_with_GitKraken.html" title="Developing FreeCAD with GitKraken/de">FreeCAD mit GitKraken entwickeln</a>, eine Anleitung zur Verwendung einer grafischen Oberfl&auml;che mit Git.</li>
<li><a rel="nofollow" class="external text" href="https://wiki.spheredev.org/index.php/Git_for_the_lazy">Git f&uuml;r die Faulpelze</a>, eine sehr pr&auml;gnante Anleitung zu den wichtigsten Befehlen von <code>git</code>.</li>
<li>Das <a rel="nofollow" class="external text" href="https://git-scm.com/book">Pro Git Buch</a>, ein quelloffenes Buch, das dich &uuml;ber Git lehrt; es ist in elektronischer und gedruckter Version erh&auml;ltlich.</li>
<li>Der <a rel="nofollow" class="external text" href="https://marklodato.github.io/visual-git-guide">Visual Git Leitfaden</a>, eine Referenz mit Diagrammen, die die h&auml;ufigsten Operationen mit Git erkl&auml;ren.</li>
<li><a rel="nofollow" class="external text" href="https://www.youtube.com/watch?v=HVsySz-h9r4">Git Tutorium f&uuml;r Anf&auml;nger: Kommandozeilen Grundlagen</a>, Video von Corey Schafer.</li>
<li><a rel="nofollow" class="external text" href="https://www.youtube.com/watch?v=uR6G2v_WsRA">Einf&uuml;hrung in Git - Kernkonzepte</a>, Video von David Mahler.</li></ul>
<div style="clear:both"></div>
<!-- 
NewPP limit report
Cached time: 20260110165109
Cache expiry: 86400
Reduced expiry: false
Complications: [show&#8208;toc]
CPU time usage: 0.131 seconds
Real time usage: 0.206 seconds
Preprocessor visited node count: 2625/1000000
Post&#8208;expand include size: 16993/2097152 bytes
Template argument size: 10313/2097152 bytes
Highest expansion depth: 6/100
Expensive parser function count: 91/100
Unstrip recursion depth: 0/20
Unstrip post&#8208;expand size: 23392/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%   85.798      1 -total
 38.63%   33.145     91 Template:Code
 10.12%    8.684     10 Template:URL
  8.09%    6.943    165 Template:Incode
  8.01%    6.876      2 Template:Caption
  4.90%    4.203      4 Template:URLn
  3.26%    2.799      1 Template:TOCright
  2.32%    1.989      1 Template:Clear
  1.97%    1.688      3 Template:Button
  1.91%    1.643      1 Template:VeryImportantMessage
-->

<!-- Saved in parser cache with key freecadweb_db01-wiki_:pcache:idhash:68505-0!canonical and timestamp 20260110165109 and revision id 1731190. Rendering was triggered because: edit-page
 -->
</div>
</div><script src="../site.js"></script>